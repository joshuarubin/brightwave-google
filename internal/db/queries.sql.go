// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const dequeue = `-- name: Dequeue :one
DELETE FROM queue WHERE id = (
    SELECT id FROM queue ORDER BY id ASC LIMIT 1
) RETURNING id, created_at, url, origin, depth, max_depth
`

func (q *Queries) Dequeue(ctx context.Context) (Queue, error) {
	row := q.queryRow(ctx, q.dequeueStmt, dequeue)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.URL,
		&i.Origin,
		&i.Depth,
		&i.MaxDepth,
	)
	return i, err
}

const enqueue = `-- name: Enqueue :exec
INSERT INTO queue (
    url,
    origin,
    depth,
    max_depth
) VALUES (
    ?,
    ?,
    ?,
    ?
) ON CONFLICT (url) DO NOTHING
`

type EnqueueParams struct {
	URL      string
	Origin   string
	Depth    int64
	MaxDepth int64
}

func (q *Queries) Enqueue(ctx context.Context, arg EnqueueParams) error {
	_, err := q.exec(ctx, q.enqueueStmt, enqueue,
		arg.URL,
		arg.Origin,
		arg.Depth,
		arg.MaxDepth,
	)
	return err
}

const getOrigins = `-- name: GetOrigins :many
SELECT origin FROM origins WHERE page_id = ?
`

func (q *Queries) GetOrigins(ctx context.Context, pageID int64) ([]string, error) {
	rows, err := q.query(ctx, q.getOriginsStmt, getOrigins, pageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var origin string
		if err := rows.Scan(&origin); err != nil {
			return nil, err
		}
		items = append(items, origin)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPage = `-- name: GetPage :one
SELECT id, created_at, modified_at, url, depth FROM pages WHERE id = ?
`

func (q *Queries) GetPage(ctx context.Context, id int64) (Page, error) {
	row := q.queryRow(ctx, q.getPageStmt, getPage, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.URL,
		&i.Depth,
	)
	return i, err
}

const getPagesForTerm = `-- name: GetPagesForTerm :many
SELECT
    pt.page_id,
    pt.count,
    origin
FROM terms AS t
JOIN page_terms AS pt on t.id = pt.term_id
RIGHT JOIN origins AS o on o.page_id = pt.page_id
WHERE term = ?
`

type GetPagesForTermRow struct {
	PageID int64
	Count  int64
	Origin string
}

func (q *Queries) GetPagesForTerm(ctx context.Context, term string) ([]GetPagesForTermRow, error) {
	rows, err := q.query(ctx, q.getPagesForTermStmt, getPagesForTerm, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPagesForTermRow
	for rows.Next() {
		var i GetPagesForTermRow
		if err := rows.Scan(&i.PageID, &i.Count, &i.Origin); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTerm = `-- name: GetTerm :one
SELECT id, created_at, term FROM terms WHERE term = ?
`

func (q *Queries) GetTerm(ctx context.Context, term string) (Term, error) {
	row := q.queryRow(ctx, q.getTermStmt, getTerm, term)
	var i Term
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Term)
	return i, err
}

const insertOrigin = `-- name: InsertOrigin :exec
INSERT INTO origins (
    page_id,
    origin
) VALUES (
    ?,
    ?
) ON CONFLICT (page_id, origin) DO NOTHING
`

type InsertOriginParams struct {
	PageID int64
	Origin string
}

func (q *Queries) InsertOrigin(ctx context.Context, arg InsertOriginParams) error {
	_, err := q.exec(ctx, q.insertOriginStmt, insertOrigin, arg.PageID, arg.Origin)
	return err
}

const insertPage = `-- name: InsertPage :one
INSERT INTO pages (
    url,
    depth
) VALUES (
    ?,
    ?
) ON CONFLICT (url) DO NOTHING
RETURNING id, created_at, modified_at, url, depth
`

type InsertPageParams struct {
	URL   string
	Depth int64
}

func (q *Queries) InsertPage(ctx context.Context, arg InsertPageParams) (Page, error) {
	row := q.queryRow(ctx, q.insertPageStmt, insertPage, arg.URL, arg.Depth)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.URL,
		&i.Depth,
	)
	return i, err
}

const insertPageTerm = `-- name: InsertPageTerm :exec
INSERT INTO page_terms (
    page_id,
    term_id
) VALUES (
    ?,
    ?
) ON CONFLICT (page_id, term_id) DO UPDATE
SET count = page_terms.count + 1
`

type InsertPageTermParams struct {
	PageID int64
	TermID int64
}

func (q *Queries) InsertPageTerm(ctx context.Context, arg InsertPageTermParams) error {
	_, err := q.exec(ctx, q.insertPageTermStmt, insertPageTerm, arg.PageID, arg.TermID)
	return err
}

const insertTerm = `-- name: InsertTerm :one
INSERT INTO terms (
    term
) VALUES (
    ?
) ON CONFLICT (term) DO NOTHING
RETURNING id, created_at, term
`

func (q *Queries) InsertTerm(ctx context.Context, term string) (Term, error) {
	row := q.queryRow(ctx, q.insertTermStmt, insertTerm, term)
	var i Term
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Term)
	return i, err
}

const isIndexed = `-- name: IsIndexed :one
SELECT id, created_at, modified_at, url, depth
FROM pages
WHERE
    url = ?
    AND modified_at >= ?
`

type IsIndexedParams struct {
	URL        string
	ModifiedAt time.Time
}

func (q *Queries) IsIndexed(ctx context.Context, arg IsIndexedParams) (Page, error) {
	row := q.queryRow(ctx, q.isIndexedStmt, isIndexed, arg.URL, arg.ModifiedAt)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.URL,
		&i.Depth,
	)
	return i, err
}

const updatePage = `-- name: UpdatePage :one
UPDATE pages SET depth = ?, modified_at = CURRENT_TIMESTAMP WHERE url = ? RETURNING id, created_at, modified_at, url, depth
`

type UpdatePageParams struct {
	Depth int64
	URL   string
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) (Page, error) {
	row := q.queryRow(ctx, q.updatePageStmt, updatePage, arg.Depth, arg.URL)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.URL,
		&i.Depth,
	)
	return i, err
}
